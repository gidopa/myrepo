
/*
각 달의 날짜수를 출력하는 예제, 12달에 대한 각 달의 날짜수가 불규칙하므로 각 달의 날짜수를 저장하기 위한 12개의 칸을 갖는 배열을 선언
그리고 일일이 대입연산자 = 을 통해 배열에 각 달의 날짜수를 대입해서 저장하면 코드가 길어지므로
배열을 만드는 동시에 초기화
*/

public class G02 {

	public static void main(String[] args) {
		int[] Days = { 31, 28, 31, 40, 31, 30, 30, 31, 30, 31, 30, 31 };
		int[][] MonDays = { { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 },
				{ 31, 28, 31, 30, 31, 30, 30, 31, 30, 31, 30, 31 } };
		for (int i = 0; i < Days.length; i++) {
			System.out.print(" " + Days[i] + " ");
		}

		System.out.println("\n --------------- ");

		for (int j = 0; j < 11; j++) {
			int month = MonDays[0][j];
			int day = MonDays[1][j];
			System.out.println(month + "월달은 " + day + "일까지 있음");		// 단일 for문으로 월 달 찍어보기
		}

		/* 향상된 for문
		 for(배열의 0 index 위치부터 1씩 증가한 원소의 값을 불러와 저장할 변수선언 : 배열명){
		 실행할 구문
		 }
		 향상된 for문은 :뒤에 적은 Days 배열의 0index 부터 11 index까지 접근하여
		 각 칸의 데이터를 차례대로 호출해 int value 변수에 저장함
		
		 장점 :간결함 : 인덱스 사용 없이 편하게 접근
		 	  가독성 : 인덱스 없이 직접 접근해 가독성이 좋아짐
		 	  컬렉션 순회 : 배열 뿐 아니라 컬렉션에도 사용가능
		 	  
		 단점 : 요소 수정 불가: 향상된 for문은 요소를 읽기만 가능하고, 요소를 수정하거나 삭제할 수 없습니다. 
		 					따라서 요소를 수정해야 하는 상황에서는 불편할 수 있습니다.
		 
			   모든 상황에 적합하지 않음: 모든 상황에 향상된 for문이 적합하지는 않습니다. 
			   						예를 들어, 특정 조건에 따라 반복을 멈추어야 하는 경우나 인덱스를 활용해야 하는 경우에는 일반적인 for문이 더 적합할 수 있습니다.
			   
			   비효율적인 요소 접근: 인덱스를 직접 다루지 않기 때문에 요소에 직접 접근해야 합니다. 
			   					이는 특정 요소에 대한 접근을 비효율적으로 만들 수 있습니다.
		*/
		
		for (int value : Days) {
			System.out.println(value);
		}
	
	}

}
